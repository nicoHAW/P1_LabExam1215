package _untouchable_.supportC2x00;


import static _untouchable_.supportC2x00.Configuration.dbgConfigurationVector;
import static _untouchable_.supportC2x00.Herald.Medium.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Array;
//
//
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
//
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/*##############################################################################
 *##############################################################################
 *###
 *###   WORKING TITEL/TERM(s)
 *###   =====================
 *
 *      "FUNCTION"  ::=  METHOD with return value (unequal void)
 *
 *      "PROCEDURE" ::=  METHOD with void as return value
 *
 *##############################################################################
 */


/**
 * LabExam11xx_4XIB1-P1    (PTP/Eclipse)<br />
 *<br />
 * This code belongs to the LabExam test support routine collection as part of some LabExam<br />
 * <br />
 * TS ::= Test Support<br />
 * Just a collection of static test support methods  that are used in particular TestFrames.
 *<br />
 *<br />
 * VCS: see ReadMe.txt
 *
 * @author   Michael Schaefers ; P1@Hamburg-UAS.eu 
 * @version  200629 #01
 */
public class TS {
    
    //##########################################################################
    //###
    //###   GENERATE & CALL
    //###
    
    /**
     * Generates requested object.
     *
     * @param requestedClassName       Class(-name) of object
     * @param requestedParameterTypes  Parameter types required by constructor
     * @param actualParameter          Actual parameter values for constructor
     *
     * @return  object generated by constructor with given pramaters
     *
     * @throws  TestSupportException
     */
    public static Object generateRequestedObject (
        final String      requestedClassName,
        final Class<?>[]  requestedParameterTypes,
        final Object[]    actualParameter
    ) throws TestSupportException {
        try{
            final Class<?> requestedClass = Class.forName( requestedClassName );
            final Object constructedObject = callConstructor( requestedClass, requestedParameterTypes, actualParameter );
            return constructedObject;
        }catch( final ClassNotFoundException ex ){
            throw new TestSupportException( String.format( "object of \"%s\" can NOT be generated properly", requestedClassName ),  ex );
        }//try
    }//method()
    //
    /**
     * Generates requested object.
     *
     * @param requestedClassName  Class(-name) of object
     *
     * @return  object generated by constructor (without any parameter)
     *
     * @throws  TestSupportException
     */
    public static Object generateRequestedObject(
        final String  requestedClassName
    ) throws TestSupportException {
        return generateRequestedObject( requestedClassName, null, null );
    }//method()
    
    /**
     * Generates object by calling constructor suitable for given parameters.
     *
     * @param classUnderTest           Class-object ( containg the constructor )
     * @param requestedParameterTypes  Parameter types defining signature respectively constructor
     * @param actualParameter          Actual parameter values for constructor
     *
     * @return  object generated by constructor with given pramaters
     *
     * @throws  TestSupportException
     */
    public static Object callConstructor (
        final Class<?>    classUnderTest,
        final Class<?>[]  requestedParameterTypes,
        final Object[]    actualParameter
    ) throws TestSupportException {
        try{
            final Constructor<?> constructor = classUnderTest.getConstructor( requestedParameterTypes );
            final Object constructedObject = constructor.newInstance( actualParameter );
            return constructedObject;
        }catch( final NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex ){
            throw new TestSupportException( String.format( "constructor for \"%s\" can NOT be called properly", classUnderTest.getSimpleName() ),  ex );
        }//try 
    }//method()
    
    /**
     * Calls  function of given object  with given parameter.
     *
     * @param objectUnderTest          Object containing the method
     * @param requestedMethodName      Name of requested method                                                         // part of Java signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method                  // part of Java signature
     * @param actualParameter          Actual parameter values for constructor
     *
     * @return  Result of method (but of type Object - most probably down cast is required)
     *
     * @throws  TestSupportException
     */
    public static Object callFunction (
        final Object objectUnderTest,
        final String requestedMethodName,                                                                               // part of Java signature
        final Class<?>[] requestedParameterTypes,                                                                       // part of Java signature
        final Object[] actualParameter
    ) throws TestSupportException {
        try{
            final Class<?> classOfObjectUnderTest = objectUnderTest.getClass();
            final Method method = classOfObjectUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            final Object result = method.invoke( objectUnderTest, actualParameter );
            return result;
        }catch( final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex ){
            throw new TestSupportException( String.format( "method \"%s\" can NOT be called properly", requestedMethodName ),  ex );
        }//try 
    }//method()
    //
    /**
     * Calls static  function ::= method with return value  of given object  with given parameter.
     *
     * @param classUnderTest           Class-object ( containg the constructor )
     * @param requestedMethodName      Name of requested method                                                         // part of Java signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method                  // part of Java signature
     * @param actualParameter          Actual parameter values for constructor
     *
     * @return  Result of method (but of type Object - most probably down cast is required)
     *
     * @throws  TestSupportException
     */
    public static Object callStaticFunction (
        final Class<?>  classUnderTest,
        final String  requestedMethodName,                                                                              // part of Java signature
        final Class<?>[]  requestedParameterTypes,                                                                      // part of Java signature
        final Object[]  actualParameter
    ) throws TestSupportException {
        try{
            final Method method = classUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            final Object result = method.invoke( null, actualParameter );                                                    // API: If the underlying method is static, then the specified obj argument is ignored. It may be null. 
            return result;
        }catch( final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex ){
            throw new TestSupportException( String.format( "method \"%s\" can NOT be called properly", requestedMethodName ),  ex );
        }//try 
    }//method()
    
    
    
    
    
    //##########################################################################
    //###
    //###   GET ...
    //###
    
    /**
     * Gets field value
     *
     * @param objectUnderTest     Object containing the field
     * @param requestedFieldName  Name of requested field
     *
     * @return  Value of requested field
     *
     * @throws  TestSupportException
     */
    public static Object getFieldValue (
        final Object objectUnderTest,
        final String requestedFieldName
    ) throws TestSupportException {
        final Class<?> classOfObjectUnderTest = objectUnderTest.getClass();
        try{
            final Field requestedField = classOfObjectUnderTest.getDeclaredField( requestedFieldName );
            requestedField.setAccessible( true );
            final Object actualValue = requestedField.getShort( objectUnderTest );
            return actualValue;
        }catch( final NoSuchFieldException ex ){
            throw new TestSupportException( String.format( "field \"%s\" can NOT be accessed properly", requestedFieldName ),  ex );
        }catch( final IllegalAccessException ex ){
            throw new TestSupportException(
                String.format(
                    "<GUARD>: call schafers for help - did NOT expect to end up here -> %s",
                    ex.getMessage()
                ),
                ex
            );
        }//try
    }//method()
    
    /**
     * Gets requested method
     *
     * @param classUnderTest           Class-object containg the method
     * @param requestedMethodName      Name of requested method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  Requested method
     *
     * @throws  TestSupportException
     */
    public static Method getMethod (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
      //final Class<?> requestedReturnType,         // it's java - return type does NOT belong to signature
        final Class<?>[] requestedParameterTypes
     ) throws TestSupportException {
        try{
            final Method method = classUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            return method;
        }catch( final NoSuchMethodException ex ){
            throw new TestSupportException( String.format( "proper method \"%s\" can NOT be found", requestedMethodName ),  ex );
        }//try 
    }//method()
    
    
    
    
    
    //##########################################################################
    //###
    //###   CHECK(s)
    //###
    
    /**
     * Checks if some object is null free
     * 
     * @param objectUnderTest the object under test
     * 
     * @return  true if object under test is null free
     */
    public static boolean isNullFree( final Object objectUnterTest ){
        if( null == objectUnterTest )  return false;
        final Class<?> classOfObjectUnterTest = objectUnterTest.getClass();
        if( ! classOfObjectUnterTest.isArray() )  return true;
        for( int i=Array.getLength( objectUnterTest );  --i>=0; ){
            final Object currentArrayElem = Array.get( objectUnterTest, i );
            if( ! isNullFree( currentArrayElem ))  return false;
        }//for
        return true;
    }//method()
    
    
    
    /**
     * Checks if interface is implemented
     *
     * @param classUnderTest          Class(-object) under test - checks if interface is implemented
     * @param requestedSuperTypeName  Name of interface that has to be implemented
     *
     * @return  true if interface is implemented, otherwise false
     */
    public static boolean isImplementing (
        final Class<?> classUnderTest,
        final String requestedSuperTypeName
    ){
        final Class<?>[] supportedInterfaces = classUnderTest.getInterfaces();
        for ( final Class<?> supportedInterface : supportedInterfaces ){
            if ( requestedSuperTypeName.equals( supportedInterface.getSimpleName() )){
                return true;
            }//if
        }//for
        return false;
    }//method()
    
    /**
     * Checks if class is super class
     *
     * @param classUnderTest          (Sub-)class(-object) under test - checks if super class is extended
     * @param requestedSuperTypeName  Name of super class that has to be extended
     *
     * @return  true if (sub-)class extends super-class, otherwise false
     */
    public static boolean isExtending (
        final Class<?> classUnderTest,
        final String requestedSuperTypeName
    ){
        final Class<?> superClass = classUnderTest.getSuperclass();
        return requestedSuperTypeName.equals( superClass.getSimpleName() );
    }//method()
    
    
    /**
     * Checks if constructor with given signature is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested constructor is supported
     * @param requestedParameterTypes  Parameter types defining signature respectively the very constructor
     *
     * @return  true if requested constructor exists, otherwise false
     */
    public static boolean isConstructor (
        final Class<?> classUnderTest, 
        final Class<?>[] requestedParameterTypes
    ){
        try{
            final Constructor<?> constructor = classUnderTest.getConstructor( requestedParameterTypes );
            return classUnderTest == constructor.getDeclaringClass();           // <=> true ;  just use(!) the contructor to protect statement before from being optimized away
        }catch( final NoSuchMethodException ex ){
            return false;
        }//try 
    }//method()
    //
    /**
     * Checks if constructor with given signature is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested constructor is supported
     *
     * @return  true if requested constructor exists, otherwise false
     */
    public static boolean isConstructor (
        final Class<?> classUnderTest
    ){
        return isConstructor( classUnderTest, null );
    }//method()
    
    
    /**
     * Checks if method with given signature and return type is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature 
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  true if requested method exists, otherwise false
     */
    public static boolean isMethod (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes,
        final Class<?> requestedReturnType
    ){
        try{
            final Method method = classUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            final Class<?> actualReturnType = method.getReturnType();
            return requestedReturnType == actualReturnType;
        }catch( final NoSuchMethodException ex ){
            return false;
        }//try 
    }//method()
    //
    /**
     * Checks if function with given signature and return type is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method                                                                   // part of Java signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method                  // part of Java signature
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature 
     *
     * @return  true if requested method exists, otherwise false
     */
    public static boolean isFunction (
        final Class<?> classUnderTest, 
        final String requestedMethodName,                                                                               // part of Java signature
        final Class<?>[] requestedParameterTypes,                                                                       // part of Java signature
        final Class<?> requestedReturnType
    ){
        assert void.class != requestedReturnType : "Uuuupppss - \"isFunction()\" checks for a function and NOT a procedure";
        return isMethod( classUnderTest, requestedMethodName, requestedParameterTypes, requestedReturnType );
    }//method()
    //
    /**
     * Checks if function with given signature (without parameter) and return type is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature 
     *
     * @return  true if requested method exists, otherwise false
     */
    public static boolean isFunction (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?> requestedReturnType
    ){
        assert void.class != requestedReturnType : "Uuuupppss - \"isFunction()\" checks for a function and NOT a procedure"; 
        return isFunction( classUnderTest, requestedMethodName, null, requestedReturnType );
    }//method()
    //
    /**
     * Checks if procedure with given signature and return type is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  true if requested method exists, otherwise false
     */
    public static boolean isProcedure (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes
    ){
        return isMethod( classUnderTest, requestedMethodName, requestedParameterTypes, void.class );
    }//method()
    //
    /**
     * Checks if procedure with given signature (without parameter) and return type is supported
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method
     *
     * @return  true if requested method exists, otherwise false
     */
    public static boolean isProcedure (
        final Class<?> classUnderTest, 
        final String requestedMethodName
    ){
        return isProcedure( classUnderTest, requestedMethodName, null );
    }//method()
    
    /**
     * Checks if method with given signature and return type is supported by class itself (and not inherited from "above")
     *
     * @param classUnderTest           Class(-object) under test - checks if requested method is supported
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  true if requested method is supported by class itself, otherwise false
     */
    public static boolean isActualMethod (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?> requestedReturnType,
        final Class<?>[] requestedParameterTypes
    ){
        try{
            final Method method = classUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            final Class<?> actualReturnType = method.getReturnType();
            return (requestedReturnType == actualReturnType) && (classUnderTest == method.getDeclaringClass() );
        }catch( final NoSuchMethodException ex ){
            return false;
        }//try 
    }//method()
    //
    /**
     * Checks if method with given signature and return type is supported by class itself (and not inherited from "above")
     *
     * @param classUnderTest           Name of class under test - checks if requested method is supported
     * @param requestedClassName       Class(-name) of object
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  true if requested method is supported by class itself, otherwise false
     *
     * @throws  TestSupportException
     */
    public static boolean isActualMethod (
        final String requestedClassName, 
        final String requestedMethodName,
        final Class<?> requestedReturnType,
        final Class<?>[] requestedParameterTypes
    ) throws TestSupportException {
        try{
            final Class<?> classUnderTest = Class.forName( requestedClassName );
            return isActualMethod( classUnderTest, requestedMethodName, requestedReturnType, requestedParameterTypes );
        }catch( final ClassNotFoundException ex ){
            throw new TestSupportException( String.format( "object of \"%s\" can NOT be generated properly", requestedClassName ),  ex );
        }//try
    }//method()
    
    
    /**
     * Checks if field (of given type) is supported by class
     *
     * @param classUnderTest      Class(-object) under test - checks if requested field is supported
     * @param requestedFieldName  Name of field
     * @param requestedType       Requested type of field
     *
     * @return  true if requested field exists, otherwise false
     *
     * @throws  TestSupportException
     */
    public static boolean isField (
        final Class<?> classUnderTest,
        final String requestedFieldName,
        final Class<?> requestedType
    ) throws TestSupportException {
        try{
            final Field requestedField = classUnderTest.getDeclaredField( requestedFieldName );
            // "setAccessible(true)" NOT required, since value is not accessed
            final Class<?> actualFieldType = requestedField.getType();
            return requestedType == actualFieldType;
        }catch( final NoSuchFieldException ex ){
            throw new TestSupportException( String.format( "field \"%s\" can NOT be accessed properly", requestedFieldName ),  ex );
        }//try
    }//method()
    
    /**
     * Checks if field (of given type) is supported by class itself (and not inherited from "above")
     *
     * @param classUnderTest      Class(-object) under test - checks if requested field is supported
     * @param requestedFieldName  Name of field
     * @param requestedType       Requested type of field
     *
     * @return  true if requested field is supported by class itself, otherwise false
     *
     * @throws  TestSupportException
     */
    public static boolean isActualField (
        final Class<?> classUnderTest,
        final String requestedFieldName,
        final Class<?> requestedType
    ) throws TestSupportException {
        try{
            final Field requestedField = classUnderTest.getDeclaredField( requestedFieldName );
            // "setAccessible(true)" NOT required, since value is not accessed
            final Class<?> actuaFieldType = requestedField.getType();
            return (requestedType == actuaFieldType) && ( classUnderTest == requestedField.getDeclaringClass() );
        }catch( final NoSuchFieldException ex ){
            throw new TestSupportException( String.format( "field \"%s\" can NOT be accessed properly", requestedFieldName ),  ex );
        }//try
    }//method()
    
    
    /**
     * Checks if reference type is an interface
     *
     * @param classUnderTest  Class(-object) under test - checks if it's an interface
     *
     * @return  true if reference type is an interface, otherwise false
     */
    public static boolean isInterface (
        final Class<?>  classUnderTest
    ){
        final boolean isInterface = classUnderTest.isInterface();
        return isInterface;
    }//method()
    
    /**
     * Checks if reference type is a class
     *
     * @param classUnderTest  Class(-object) under test - checks if it's a class
     *
     * @return  true if reference type is a class, otherwise false
     */
    public static boolean isClass (
        final Class<?>  classUnderTest
    ){
        final boolean isSomeClass = !classUnderTest.isInterface();
        return isSomeClass;
    }//method()
    
    
    
    //--------------------------------------------------------------------------
    //
    // check access modifier
    //
    
    /**
     * Checks if coded modifier is "friendly" resp. "default scope" resp. "package scope" resp. "package private" or whatsoever name it might have at this point of time
     *
     * @param modifier  Modifier coded in JAVA-reflection-way as int
     *
     * @return  true if modifier is "friendly", otherwise false
     */
    private static boolean isFriendly (
        final int  modifier
    ){
        return 0 == ( modifier & ( Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE ));
    }//method()
    
    
    
    /**
     * Checks if a requested (access) modifier is set (for given class)
     *
     * @param classUnderTest     Class(-object) under test
     * @param requestedModifier  Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedClassAccessModifierSet (
        final Class<?>  classUnderTest,
        final int  requestedModifier
    ){
        final int actualModifiers = classUnderTest.getModifiers();
        final boolean requestedAccessModifierSet = ( 0 != ( requestedModifier & actualModifiers ) );
        return requestedAccessModifierSet;
    }//method()
    //
    /**
     * Checks if given class is public
     *
     * @param classUnderTest     Class(-object) under test
     *
     * @return  true if given class is public
     */
    public static boolean isClassPublic (
        final Class<?>  classUnderTest
    ){
        return  isRequestedClassAccessModifierSet( classUnderTest, Modifier.PUBLIC );
    }//method()
    
    
    
    /**
     * Checks if a requested (access) modifier is set (for constructor defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedParameterTypes  Parameter types defining signature respectively the very constructor
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedConstructorAccessModifierSet (
        final Class<?> classUnderTest, 
        final Class<?>[] requestedParameterTypes,
        final int requestedModifier
    ){
        try{
            final Constructor<?> constructor = classUnderTest.getConstructor( requestedParameterTypes );
            final int actualModifiers = constructor.getModifiers();
            final boolean requestedAccessModifierSet = ( 0 != ( requestedModifier & actualModifiers ) );
            return requestedAccessModifierSet;
        }catch( final NoSuchMethodException ex ){
            return false;
        }//try 
    }//method()
    //
    /**
     * Checks if a requested (access) modifier is set (for constructor defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedConstructorAccessModifierSet (
        final Class<?> classUnderTest, 
        final int requestedModifier
    ){
        return isRequestedConstructorAccessModifierSet( classUnderTest, null, requestedModifier );
    }//method()
    //
    /**
     * Checks if construcotr is public
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedParameterTypes  Parameter types defining signature respectively the very constructor
     * @param requestedModifier        Requested modifier
     *
     * @return  true if construcotr is public
     */
    public static boolean isConstructorPublic (
        final Class<?> classUnderTest, 
        final Class<?>[] requestedParameterTypes
    ){
        return isRequestedConstructorAccessModifierSet( classUnderTest, requestedParameterTypes, Modifier.PUBLIC );
    }//method()
    //
    /**
     * Checks if constructor (without parameter) is public
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedModifier        Requested modifier
     *
     * @return  true if construcotr is public
     */
    public static boolean isConstructorPublic (
        final Class<?> classUnderTest
    ){
        return isConstructorPublic( classUnderTest, null );
    }//method()
    
    
    
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedMethodAccessModifierSet (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?> requestedReturnType,
        final Class<?>[] requestedParameterTypes,
        final int requestedModifier
    ){
        try{
            final Method method = classUnderTest.getMethod( requestedMethodName, requestedParameterTypes );
            final Class<?> actualReturnType = method.getReturnType();
            if( requestedReturnType == actualReturnType ){
                final int actualModifiers = method.getModifiers();
                final boolean requestedAccessModifierSet = ( 0 != ( requestedModifier & actualModifiers ) );
                return requestedAccessModifierSet;
            }else{
                return false;
            }//if
        }catch( final NoSuchMethodException ex ){
            return false;
        }//try
    }//method()
    //
    //--------------------------------------------------------------------------
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedFunctionAccessModifierSet (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes,
        final Class<?> requestedReturnType,
        final int requestedModifier
    ){
        return isRequestedMethodAccessModifierSet ( classUnderTest, requestedMethodName, requestedReturnType, requestedParameterTypes, requestedModifier );
    }//method()
    //
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedFunctionAccessModifierSet (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?> requestedReturnType,
        final int requestedModifier
    ){
        return isRequestedFunctionAccessModifierSet ( classUnderTest, requestedMethodName, null, requestedReturnType, requestedModifier );
    }//method()
    //
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     *
     * @return  true if function is public, otherwise false
     */
    public static boolean isFunctionPublic (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes,
        final Class<?> requestedReturnType
    ){
        return isRequestedFunctionAccessModifierSet( classUnderTest, requestedMethodName, requestedParameterTypes, requestedReturnType, Modifier.PUBLIC );
    }//method()
    //
    /**
     * Checks if function (withoud parameter) is public
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedReturnType      Requested return type of method result - ATTENTION: For JAVA the return type does NOT belong to the signature
     *
     * @return  true if function is public, otherwise false
     */
    public static boolean isFunctionPublic (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?> requestedReturnType
    ){
        return isFunctionPublic( classUnderTest, requestedMethodName, null, requestedReturnType );
    }//method()
    //
    //--------------------------------------------------------------------------
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedProcedureAccessModifierSet (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes,
        final int requestedModifier
    ){
        return isRequestedMethodAccessModifierSet( classUnderTest, requestedMethodName, void.class, requestedParameterTypes, requestedModifier );
    }//method()
    //
    /**
     * Checks if a requested (access) modifier is set (for method defined by given parameter types)
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedModifier        Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedProcedureAccessModifierSet (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final int requestedModifier
    ){
        return isRequestedProcedureAccessModifierSet( classUnderTest, requestedMethodName, null, requestedModifier );
    }//method()
    //
    /**
     * Checks if procedure is public
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     * @param requestedParameterTypes  Parameter types defining signature respectively the very method
     *
     * @return  true if procedure is public, otherwise false
     */
    public static boolean isProcedurePublic (
        final Class<?> classUnderTest, 
        final String requestedMethodName,
        final Class<?>[] requestedParameterTypes
    ){
        return isRequestedProcedureAccessModifierSet( classUnderTest, requestedMethodName, requestedParameterTypes, Modifier.PUBLIC );
    }//method()
    //
    /**
     * Checks if procedure (without parameter) is public
     *
     * @param classUnderTest           Class(-object) under test
     * @param requestedMethodName      Name of method
     *
     * @return  true if procedure is public, otherwise false
     */
    public static boolean isProcedurePublic (
        final Class<?> classUnderTest, 
        final String requestedMethodName
    ){
        return isProcedurePublic( classUnderTest, requestedMethodName, null );
    }//method()
    
    /**
     * Checks if a requested (access) modifier is set (for field)
     *
     * @param fieldUnderTest     Field under test
     * @param requestedModifier  Requested modifier
     *
     * @return  true if requested modifier is set, otherwise false
     */
    public static boolean isRequestedFieldAccessModifierSet (
        final Field  fieldUnderTest,
        final int  requestedModifier
    ){
        final int actualModifiers = fieldUnderTest.getModifiers();
        final boolean requestedAccessModifierSet = ( 0 != ( requestedModifier & actualModifiers ) );
        return requestedAccessModifierSet;
    }//method()
    
    /**
     * Checks if all variable (field) access modifiers are set private
     *
     * @param classUnderTest  Class(-object) under test
     *
     * @return  true if all variables are private, otherwise false
     */
    public static boolean allVariableFieldAccessModifiersPrivate (
        final Class<?> classUnderTest
    ){
        final Field[] actualFields = classUnderTest.getDeclaredFields();
        for ( final Field actualField : actualFields ){
            if (    actualField.getDeclaringClass() == classUnderTest
                &&  !Modifier.isFinal( actualField.getModifiers() )
                &&  !Modifier.isPrivate( actualField.getModifiers() )
                &&  !Pattern.matches( ".*\\$.*", actualField.getName() )        // check for auto generated names (e.g. "$assertionsDisabled")      _???_160122
            ){
                return false;
            }//if
        }//for
        return true;
    }//method()
    
    
    
    
    //--------------------------------------------------------------------------
    //
    // check notation
    //
    
    /**
     * Checks if there is any invalid field notation
     *
     * @param classUnderTest  Class(-object) under test
     *
     * @return  an example (respectively field name) for an invalid field notation, otherwise null
     */
    public static String hasInvalidFieldNotation (
        final Class<?> classUnderTest
    ){
        final boolean dbgLocalAddInfoEnable = ( 0 != ( dbgConfigurationVector & 0x20_0000 ));   // for additional debug/check output
        int suspicionLevel = 0;                                                 // for $... variables
        String preamble = "";                                                   // preamble in case of $... variables
        //
        final Field[] actualFields = classUnderTest.getDeclaredFields();
        // "setAccessible(true)" NOT required, since value is not accessed
        for ( final Field actualField : actualFields ){
            suspicionLevel = 0;                                                 // for $... variables
            preamble = "";                                                      // preamble in case of $... variables
            //
            if ( actualField.getDeclaringClass() == classUnderTest ){
                final String actualFieldName = actualField.getName();
                if ( Modifier.isFinal( actualField.getModifiers() )){
                    //\=> constant  respectively variable is FINAL
                  //if( ! Pattern.matches(  "[A-Z][_0-9A-Z]*",    actualFieldName )){   // the VERY JAVA LAW (for state related final fields)
                    if( ! Pattern.matches( "([A-Z][_0-9A-Z]*)|([a-z][_0-9A-Za-z]*)",  actualFieldName )){   // Ok, I am an outlaw and some students might follow - do NOT blame it on them - blame it on me
                        //\=> the VERY JAVA LAW (for variables/fields) is broken
                        //
                        suspicionLevel = Integer.MAX_VALUE;
                    }//if
                }else{
                    //\=> NO constant  respectively variable is NOT final
                    if( ! Pattern.matches( "[a-z][_0-9A-Za-z]*",  actualFieldName )){   // the VERY JAVA LAW (for variable fields)
                        //\=> the VERY JAVA LAW (for variables/fields) is broken
                        //
                        suspicionLevel = Integer.MAX_VALUE;
                    }//if
                }//if
                //\=> now it is known, if the Java variable naming conventions are fulfilled  (-> inside suspicionLevel)
                //
                if( 0 < suspicionLevel ){
                    //\=> somehow the VERY JAVA LAW (for naming of variables/fields) is broken
                    //
                    // but, sometimes auto generated variable names become visible - check if variable name starts with $
                    if( Pattern.matches( "\\$.*",  actualFieldName )){
                        //\=> some kind of $variable - only allowed for auto generated variables names - but sometimes those variables become "visible"
                        //
                        if( actualFieldName.equals( "$assertionsDisabled" )){
                            //\=> internal $assertionsDisabled variable marks if assert is disabled or not  -  this variable is quite often visible
                            //
                            suspicionLevel = 1;
                            if( dbgLocalAddInfoEnable )  preamble = String.format( "$assertionsDisabled as variable ? -> possible notation error detected for : \"%s\"\n",  actualFieldName );
                        }else if( Pattern.matches( "\\$SWITCH_TABLE*",  actualFieldName )){
                            //\=> is "sometimes" generated in context of the switch statement
                            //
                            suspicionLevel = 2;
                            if( dbgLocalAddInfoEnable )  preamble = String.format( "$SWITCH_TABLE... as variable ? -> possible notation error detected for : \"%s\"\n",  actualFieldName );
                        }else{
                            //\=> what else might be out there?
                            suspicionLevel = 3;
                            if( dbgLocalAddInfoEnable )  preamble = String.format( "$ marked variable ? -> possible notation error detected for : \"%s\"\n",  actualFieldName );
                        }//if
                        //
                        if( dbgLocalAddInfoEnable  ||  ( 2<= suspicionLevel )){
                            //\=> print message on screen
                            //
                            Herald.proclaimMessage( SYS_OUT, String.format(
                                "%s"
                              + "Note for schaefers :  \"%s\" found in %s  -  this might be OK but also an ERROR  -  it has to be checked manually in source code\n"
                              + "TO THE EXAMINEE :     If you do NOT have declared a variable with that name - everything should be fine\n",
                                preamble,
                                actualFieldName,
                                classUnderTest.getSimpleName()
                            ));
                        }//if
                        //
                    }else{
                        //\=> actualFieldName is NO $variable -> hence, it is considered as an error
                        //
                        return actualFieldName;
                    }//if
                }//if                    
            }//if
        }//for
        return null;
    }//method()    
    
    /**
     * Checks if there is any invalid method notation
     *
     * @param classUnderTest  Class(-object) under test
     *
     * @return  an example (respectively method name) for an invalid method notation, otherwise null
     */
    public static String hasInvalidMethodNotation (
        final Class<?> classUnderTest
    ){
        final Field[] actualFields = classUnderTest.getDeclaredFields();
        final Method[] methods = classUnderTest.getMethods();
        for( final Method actualMethod : methods ){
            final String actualMethodName = actualMethod.getName();
            if (    actualMethod.getDeclaringClass() == classUnderTest
                &&  !Pattern.matches( "[a-z][_0-9A-Za-z]*",  actualMethodName ) // the VERY JAVA LAW (for methods)
            ){
              //Herald.proclaimMessage( SYS_OUT,  String.format( "Notation error detected for : \"%s\"\n",  actualMethodName ));
                return actualMethodName;
            }//if
        }//for
        return null;
    }//method()      
    
    /**
     * Checks if there is an invalid class notation (in case of self defined class name ;-)
     *
     * @param classUnderTest  Class(-object) under test
     *
     * @return  the class name in case of invalid class notation, otherwise null
     */
    public static String hasInvalidClassNotation (
        final Class<?> classUnderTest
    ){
        final String actualClassName = classUnderTest.getSimpleName();
        if( ! classUnderTest.isAnonymousClass() ){
            //\=> it is NO anonymous class => hence, student has defined the class name that has to be checked
            if( ! Pattern.matches( "[A-Z][_0-9A-Za-z]*",  actualClassName )){
                return actualClassName;
            }//if
        }//if
        return null;
    }//method()
    
    
    
    
    //--------------------------------------------------------------------------
    //
    // check for forbidden
    //
    
    /**
     * Checks if object is of (or derived from) forbidden reference type.
     * Reference type neams reference type - simple types are NOT supported.
     *
     * @param objectUnderTest  Object under test
     * @param forbiddenTypes   Array containing forbidden types
     *
     * @return  true if object is of forbidden type, otherwise false
     */
    public static boolean isOfForbiddenReferenceType (
        final Object objectUnderTest,
        final Class<?>[] forbiddenTypes
    ){
        for( final Class<?> forbiddenType : forbiddenTypes ){
            if( forbiddenType.isInstance( objectUnderTest )){
                return true;
            }//if
        }//for
        return false;
    }//method()
    
    /**
     * Checks if class is of (or derived from) forbidden type.
     * Note: Simple type are supported, too.
     *
     * @param classUnderTest  Class(-object) under test
     * @param forbiddenTypes  Array containing forbidden types
     *
     * @return  true if class is of forbidden type, otherwise false
     */
    public static boolean isOfForbiddenType (
        final Class<?> classUnderTest,
        final Class<?>[] forbiddenTypes
    ){
        for( final Class<?> forbiddenType : forbiddenTypes ){
            if( forbiddenType.isAssignableFrom( classUnderTest )){
                return true;     // tests whether the type represented by the specified Class parameter can be converted to the type represented by cut via an IDENTITY conversion or via a widening reference conversion. 
            }//if
        }//for
        return false;
    }//method()
    
    
    /**
     * Checks if class contains anything that is of forbidden reference type
     *
     * @param requestedClassName  Class(-name) of object
     * @param forbiddenTypes      Array containing forbidden types
     *
     * @return  true if there's any (direct) class element of forbidden type, otherwise false
     *
     * @throws  TestSupportException
     */
    public static boolean containsForbiddenType (
        final String requestedClassName,
        final Class<?>[] forbiddenTypes
    ) throws TestSupportException {
        try{
            final Class<?> classUnderTest = Class.forName( requestedClassName );
            return containsForbiddenType( classUnderTest, forbiddenTypes );
        }catch( final ClassNotFoundException ex ){
            throw new TestSupportException( String.format( "class \"%s\" can NOT be found", requestedClassName ),  ex );
        }//try
    }//method()
    //
    /**
     * Checks if class contains anything that is of forbidden reference type
     *
     * @param classUnderTest  Class(-object) under test
     * @param forbiddenTypes  Array containing forbidden types
     * 
     * @return  true if there's any (direct) class element of forbidden type, otherwise false
     */
    public static boolean containsForbiddenType (
        final Class<?> classUnderTest,
        final Class<?>[] forbiddenTypes
    ){
        final Field[] theFields = classUnderTest.getDeclaredFields();
        for( final Field field : theFields ){
            /*
            if ( ! Pattern.matches( ".*\\$.*", field.getName() )){
                //\=> field is NOT auto generated (e.g. "$assertionsDisabled")      _???_160122
            */
            if( isOfForbiddenType( field.getType(), forbiddenTypes )){
                Herald.proclaimMessage( SYS_ERR, String.format(
                    "XXX\n"
                  + "XXX ATTENTION:\n"
                  + "XXX FORBIDDEN TYPE detected - this can NOT automatically verified with 100%% reliability, but manual checks will be done!\n"
                  + "XXX YOU WILL LOSE ALL POINTS  if you are using forbidden types !!!\n"
                  + "XXX class : %s    object_reference_variable : %s    type : %s\n"
                  + "XXX\n",
                    classUnderTest.getSimpleName(),
                    field.getName(),
                    field.getType().getSimpleName()
                ));
                return true;
            }//if
        }//for
        return false;
    }//method()
    
    
    /**
     * Checks if class contains anything (directly or indirectly) that is of forbidden reference type
     *
     * @param requestedClassName  ...
     * @param forbiddenTypes      Array containing forbidden types
     *
     * @return  true if there's anything of forbidden type, otherwise false
     *
     * @throws  TestSupportException
     */
    public static boolean deepContainsForbiddenType(
        final String requestedClassName,
        final Class<?>[] forbiddenTypes
    ) throws TestSupportException {
        try{
            final Class<?> classUnderTest = Class.forName( requestedClassName );
            return deepContainsForbiddenType( classUnderTest, forbiddenTypes );
        }catch( final ClassNotFoundException ex ){
            throw new TestSupportException( String.format( "class \"%s\" can NOT be found", requestedClassName ),  ex );
        }//try
    }//method()
    //
    /**
     * Checks if class contains anything (directly or indirectly) that is of forbidden reference type
     *
     * @param classUnderTest  Class(-object) under test
     * @param forbiddenTypes  Array containing forbidden types
     *
     * @return  true if there's anything of forbidden type, otherwise false
     */
    public static boolean deepContainsForbiddenType(
        final Class<?> classUnderTest,
        final Class<?>[] forbiddenTypes
    ){
        final Field[] theFields = classUnderTest.getDeclaredFields();
        for( final Field field : theFields ){
            if( isOfForbiddenType( field.getType(), forbiddenTypes )){
                Herald.proclaimMessage( SYS_ERR, String.format(
                    "XXX\n"
                  + "XXX ATTENTION:\n"
                  + "XXX FORBIDDEN TYPE detected - this can NOT automatically verified with 100%% reliability, but manual checks will be done!\n"
                  + "XXX YOU WILL LOSE ALL POINTS  if you are using forbidden types !!!\n"
                  + "XXX class : %s    object_reference_variable : %s    type : %s\n"
                  + "XXX\n",
                    classUnderTest.getSimpleName(),
                    field.getName(),
                    field.getType().getSimpleName()
                ));
                return true;
            }//if
            //
            final Class<?> superClass = classUnderTest.getSuperclass();
            if(( superClass != null )  &&  ( superClass != Object.class )){
                if( deepContainsForbiddenType( superClass, forbiddenTypes )){
                    return true;
                }//if
            }//if
        }//for
        return false;
    }//method()
    
    
    /**
     * Checks if class contains TODOs
     */
    public static boolean containsSuspiciousToDoMarks(
        final String testName,
        final RefTypeInfoContainer refTypeInfoContainer,
        /*
        final String requestedRefTypeName,
        final String requestedRefTypeWithPath,
        final String pathToJavaRootBinHome,
        final String localPackagePath,
        */
        final ManualTodoInvestigationRelatedAddOn manualTodoInvestigationRelatedAddOn                             // <-> Exception
    ){
        switch( manualTodoInvestigationRelatedAddOn ){
            case NONE:
                boolean suspiciousTodoFound = false;
                final Class<?> classUnderTest = refTypeInfoContainer.referenceTypeUnderTest;
                final File sourceCodeOfClassUnderText = refTypeInfoContainer.sourceCodeOfClassUnderText;
                /*
                final String pathToJavaRootSourceHome = pathToJavaRootBinHome.replaceFirst( "/bin/$", "/src/" );
                final String localPackagePathAdapted = localPackagePath.replaceAll( "\\.", "\\\\" );
                final String pathToSourceCodeOfClassUnderText = pathToJavaRootSourceHome + localPackagePathAdapted + "\\" + requestedRefTypeName + ".java";
                final File sourceCodeOfClassUnderText = new File( pathToSourceCodeOfClassUnderText );
                */
                //
                final Pattern unwantedPattern = Pattern.compile( ".*// TODO Auto-generated.*stub.*" );
                try(
                    final BufferedReader br = new BufferedReader( new FileReader( sourceCodeOfClassUnderText ));
                ){
                    String line;
                    while( null != ( line = br.readLine())){
                        final Matcher matcher = unwantedPattern.matcher( line );
                        if( matcher.find() ){
                            suspiciousTodoFound = true;
                        }else if(
                                line.matches( ".*TODO.*")
                            ||  line.matches( ".*Auto-generated.*" )
                          ){
                            final StringBuffer sb = new StringBuffer();
                            sb.append( testName );
                            sb.append( " -> " );
                            sb.append( classUnderTest.getSimpleName() );
                            sb.append( "\n" );
                            sb.append( line );
                            Herald.proclaimMessage( SYS_OUT, sb );
                            suspiciousTodoFound = true;
                        }//if
                    }//while
                }catch( final FileNotFoundException ex ){
                    ex.printStackTrace();
                }catch( final IOException ex ){
                    ex.printStackTrace();
                }//try
                return suspiciousTodoFound;
            case PROVED_ACCEPTABLE:
                return false;
            case PROVED_UNACCEPTABLE:
                return true;
            default:
                assert false : "Uuuupppss : INTERNAL programming error";
                return false;
        }//switch
    }//method()
    //
    public static boolean containsSuspiciousToDoMarks(
            final String testName,
            final RefTypeInfoContainer refTypeInfoContainer
    ){
        return containsSuspiciousToDoMarks( testName, refTypeInfoContainer, ManualTodoInvestigationRelatedAddOn.NONE );
    }//method()
    
    
    
    //--------------------------------------------------------------------------
    //
    // check test configuration
    //
    
    /**
     * Checks if requested bits are set in configuration.
     *
     * @param bitsRequested  the bits requested to be set in test configuration
     *
     * @return  true if requested bits are set, otherwise false
     */
    public static boolean checkTestConfiguration( final long bitsRequested ){
        final boolean resu = ( bitsRequested == ( dbgConfigurationVector & bitsRequested ));
        return resu;
    }//method()
    
    
    
    
    
    //##########################################################################
    //###
    //###   EQUALs variants
    //###
    
    /**
     * Checks if both ("one dimensional") arrays contain equal content.
     * Meaning same amount of array entries and
     * for each array-entry there is an equal counterpart entry in the other array.
     * The elements/entries can be ordered in any way in each of both arrays.
     * The order of the elements/entries is allowed to differ.
     *
     * @param array1st  1st array
     * @param array2nd  2nd array
     *
     * @return  true both arrays contain equal content (independent of the element order)
     */
    public static boolean containEqualContentOn1stLevel(
        final Object[] array1st,                                                // reference array containing expected content
        final Object[] array2nd                                                 // array under test that shall contain "the same"
    ){
        if( array1st == array2nd )  return true;                                // if both are null, it's ok ;-)
        if( (null == array1st) || (null == array2nd) )  return false;           // if a single one is null it's NOT ok
        if( array1st.length != array2nd.length )  return false;                 // both must have the same "number of entries" resp. same size
        //
        // start checking entries
        final List<Object> list1st = new ArrayList<>();
        for( final Object currentObject : array1st )  list1st.add( currentObject );
        for( final Object currentObject : array2nd ){
            if( ! list1st.remove( currentObject ))  return false;
        }//for
        //\=> list1st has to be empty, since same size and "all" removed
        //
        return list1st.isEmpty();                                               // for safety's sake - you never know, what might result out of programming errors ;-)
    }//method()
    
    /**
     * ...
     */
    public static boolean containEqualContent(
        final Object[]      arrayRef,                                           // reference array containing expected content
        final Collection<?> coll                                                // collection under test that shall contain "the same" - NO generic on purpose => coll can take ANY collection
    ){
        return containEqualContentOn1stLevel( arrayRef, coll.toArray() );
    }//method()
    
    
    
    
    
    //##########################################################################
    //###
    //###   EXAMINE exception(s)
    //###
    
    /**
     * Examines internally raised test support exception if is raised as a result of an illegal argument and reacts in a proper way.
     *
     * @param methodName                               name of test(-method)
     * @param ex                                       exeption(-object)
     * @param manualInvestigationRelatedAddOn           manual exception investigation setting
     */
    public static void examineInternallyRaisedTestSupportExceptionForIllegalArgumentCauseAndReact (
        final String methodName,
        final TestSupportException ex,
        final ManualExceptionInvestigationRelatedAddOn manualInvestigationRelatedAddOn
    ){
        final Throwable causingThrowable = ex.getCause();
        if( null == causingThrowable ){
            JUW.jufail( String.format( "can NOT generate object - %s", ex.getMessage() ));
        }else if( causingThrowable instanceof InvocationTargetException ){
            final Throwable actualCausingThrowable = ((InvocationTargetException)causingThrowable ).getCause();
            if(     actualCausingThrowable instanceof AssertionError
                ||  actualCausingThrowable instanceof IllegalArgumentException
            ){
                // fine :-)
            }else{
                //\=> seems to be an unwanted/unacceptable exception => take a look at exceptionInvestigationSetting
                //
                switch( manualInvestigationRelatedAddOn ){
                    case NONE :
                        printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  actualCausingThrowable, methodName );
                        JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  actualCausingThrowable.getClass().getSimpleName(), actualCausingThrowable.getMessage() ));
                        break;
                    case ENABLE_PRINT_STACK_TRACE :
                        printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  actualCausingThrowable, methodName );
                        actualCausingThrowable.printStackTrace();
                        JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  actualCausingThrowable.getClass().getSimpleName(), actualCausingThrowable.getMessage() ));
                        break;
                    case ENABLE_PRINT_STACK_TRACE_AND_PROVED_ACCEPTABLE :
                        actualCausingThrowable.printStackTrace();
                        break;
                    case ENABLE_PRINT_STACK_TRACE_AND_PROVED_UNACCEPTABLE :
                        actualCausingThrowable.printStackTrace();
                        JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  actualCausingThrowable.getClass().getSimpleName(), actualCausingThrowable.getMessage() ));
                        break;
                    case PROVED_ACCEPTABLE :
                        break;
                    case PROVED_UNACCEPTABLE :
                        JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  actualCausingThrowable.getClass().getSimpleName(), actualCausingThrowable.getMessage() ));
                        break;
                    default :
                        assert false : "Uuuupppss : INTERNAL programming error";
                        break;
                }//switch
            }//if
        }else if(   causingThrowable instanceof ClassNotFoundException
                ||  causingThrowable instanceof NullPointerException
        ){
            JUW.jufail( String.format( "can NOT generate object - %s", causingThrowable.getMessage() ));
        }else{
            //\=> situation unclear/unexpected => take a look at exceptionInvestigationSetting
            //
            switch( manualInvestigationRelatedAddOn ){
                case NONE :
                    printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  causingThrowable, methodName );
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  causingThrowable.getClass().getSimpleName(), causingThrowable.getMessage() ));
                    break;
                case ENABLE_PRINT_STACK_TRACE :
                    printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  causingThrowable, methodName );
                    causingThrowable.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  causingThrowable.getClass().getSimpleName(), causingThrowable.getMessage() ));
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_ACCEPTABLE :
                    causingThrowable.printStackTrace();
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_UNACCEPTABLE :
                    causingThrowable.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  causingThrowable.getClass().getSimpleName(), causingThrowable.getMessage() ));
                    break;
                case PROVED_ACCEPTABLE :
                    break;
                case PROVED_UNACCEPTABLE :
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  causingThrowable.getClass().getSimpleName(), causingThrowable.getMessage() ));
                    break;
                default :
                    assert false : "Uuuupppss : INTERNAL programming error";
                    break;
            }//switch
        }//if
    }//method();
    //
    /**
     * Examines internally raised test support exception if is raised as a result of an illegal argument and reacts in aproper way.
     *
     * @param methodName  name of test(-method)
     * @param ex          exeption(-object)
     */
    public static void examineInternallyRaisedTestSupportExceptionForIllegalArgumentCauseAndReact (
        final String  methodName,
        final TestSupportException  ex
    ){
        examineInternallyRaisedTestSupportExceptionForIllegalArgumentCauseAndReact( methodName, ex, ManualExceptionInvestigationRelatedAddOn.NONE );
    }//method()
    
    
    /**
     * Examines raised exception if it is raised as a result of detected illegal argument and reacts in a proper way.
     *
     * @param methodName                               name of test(-method)
     * @param ex                                       exeption(-object)
     * @param manualExceptionInvestigationSetting      manual exception investigation setting
     */
    public static void examineExceptionForIllegalArgumentCauseAndReact (
        final String methodName,
        final Throwable ex,
        final ManualExceptionInvestigationRelatedAddOn manualInvestigationRelatedAddOn
    ){
        if(     ex instanceof AssertionError
            ||  ex instanceof IllegalArgumentException
        ){
            // fine :-)
        }else{
            //\=> seems to be an unwanted/unacceptable exception => take a look at exceptionInvestigationSetting
            //
            switch( manualInvestigationRelatedAddOn ){
                case NONE :
                   printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  ex, methodName );
                   JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                   break;
                case ENABLE_PRINT_STACK_TRACE :
                    printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  ex, methodName );
                    ex.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_ACCEPTABLE :
                    ex.printStackTrace();
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_UNACCEPTABLE :
                    ex.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    break;
                case PROVED_ACCEPTABLE :
                    break;
                case PROVED_UNACCEPTABLE :
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    break;
               default :
                   assert false : "Uuuupppss : INTERNAL programming error";
                   break;
           }//switch
        }//if
    }//method();
    //
    /**
     * Examines raised exception if it iss raised as  a result of an illegal state and reacts in a proper way.
     *
     * @param methodName  name of test(-method)
     * @param ex          exeption(-object)
     */
    public static void examineExceptionForIllegalArgumentCauseAndReact (
        final String  methodName,
        final Throwable  ex
    ){
        examineExceptionForIllegalArgumentCauseAndReact( methodName, ex, ManualExceptionInvestigationRelatedAddOn.NONE );
    }//method()
    
    
    /**
     * Examines raised exception if it is raised as a result of an illegal state and reacts in a proper way.
     *
     * @param methodName                               name of test(-method)
     * @param ex                                       exeption(-object)
     * @param manualExceptionInvestigationSetting      manual exception investigation setting
     */
    public static void examineExceptionForIllegalStateCauseAndReact (
        final String methodName,
        final Throwable ex,
        final ManualExceptionInvestigationRelatedAddOn manualInvestigationRelatedAddOn
    ){
        if(     ex instanceof AssertionError
            ||  ex instanceof IllegalStateException
        ){
            // fine :-)
        }else{
            //\=> seems to be an unwanted/unacceptable exception => take a look at exceptionInvestigationSetting
            //
            switch( manualInvestigationRelatedAddOn ){
                case NONE :
                    printInternalNote4Exception( "\"this\" is considered as an ERROR, but since \"this\" was either unexpected or can NOT be fully automated, it might be ok. it has to be checked manually in source code",  ex, methodName );
                    ex.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                case ENABLE_PRINT_STACK_TRACE :
                    ex.printStackTrace();
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_ACCEPTABLE :
                    ex.printStackTrace();
                    break;
                case ENABLE_PRINT_STACK_TRACE_AND_PROVED_UNACCEPTABLE :
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    ex.printStackTrace();
                    break;
                case PROVED_ACCEPTABLE :
                    break;
                case PROVED_UNACCEPTABLE :
                    JUW.jufail( String.format( "UNEXPECTED exception :  ( %s -> %s )",  ex.getClass().getSimpleName(), ex.getMessage() ));
                    break;
                default :
                    assert false : "Uuuupppss : INTERNAL programming error";
                    break;
            }//switch
        }//if
    }//method();
    //
    /**
     * Examines raised exception if it is raised as a result of an illegal state and reacts in a proper way.
     *
     * @param methodName  name of test(-method)
     * @param ex          exception(-object)
     */
    public static void examineExceptionForIllegalStateCauseAndReact (
        final String  methodName,
        final Throwable  ex
    ){
        examineExceptionForIllegalStateCauseAndReact( methodName, ex, ManualExceptionInvestigationRelatedAddOn.NONE );
    }//method()
    
    
    
    
    
    //--------------------------------------------------------------------------
    //
    //
    //
    
    /**
     * prints internal note for exception
     *
     * @param cause       cause
     * @param throwable   throwable(-object)
     * @param methodName  name of test(-method)
     */
    public static void printInternalNote4Exception(
        final String cause,
        final Throwable throwable,
        final String methodName
    ){
        if( throwable.getClass() != TestSupportException.class ){
            Herald.proclaimMessage( SYS_ERR,  String.format(
                "\n####\nvvvv\n[<INTERNAL NOTE> for schafers:\n    %s\n    ( %s -> %s )]\n@%s\n^^^^\n####\n\n",
                cause,
                throwable.getClass().getSimpleName(),
                throwable.getMessage(),
                methodName
            ));
        }else{
            Herald.proclaimMessage( SYS_ERR,  String.format(
                "\n####\nvvvv\n[<INTERNAL NOTE> for schafers:\n    %s\n    ( %s -> %s -->> %s -> %s )]\n@%s\n^^^^\n####\n\n",
                cause,
                throwable.getClass().getSimpleName(),  
                throwable.getMessage(),
                ((TestSupportException)throwable).getCause().getClass().getSimpleName(),
                ((TestSupportException)throwable).getCause().getMessage(),
                methodName
            ));
        }//if
    }//method()
    
    
    
    
    
    
    
    
    
    
    //##########################################################################
    //###VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //###
    //###   additional stuff that is NOT delivered with code above <<<---??? TODO NEW HEADER REQUIRED
    //###
    
    /**
     * prints detailed information about given object
     *
     * @param objectUnderTest        object under test
     * @param nameOfObjectUnderTest  name variable referencing object
     */
    public static void printDetailedInfoAboutObject (
        final Object objectUnderTest,
        final String nameOfObjectUnderTest
    ){
        try{
            // name of object itself & toString
            if( null != nameOfObjectUnderTest ){
                for( int stillToDo = 12-nameOfObjectUnderTest.length(); --stillToDo>=0; )  System.out.printf( ">" );
                System.out.printf( "%s:\n",  nameOfObjectUnderTest );
            }else{
                System.out.printf( "~~~~~~~~~~~~:\n" );
            }//if
            
            // class
            final Class<?> theClass = objectUnderTest.getClass();
            final int actualModifiers = theClass.getModifiers();
            System.out.printf( "~~~~~~~class:  %s   is   %s",  theClass.getSimpleName(), modifiersToString( actualModifiers ));
            
            boolean blankRequired = false;
            final Class<?> superClass = theClass.getSuperclass();
            if( superClass != Object.class ){
                System.out.printf( " extends %s", superClass.getSimpleName() );
                blankRequired = true;
            }//if
            
            final Class<?>[] supportedInterfaces = theClass.getInterfaces();
            if( 0 < supportedInterfaces.length ){
                if( blankRequired )  System.out.printf( " " );
                System.out.printf( " implements" );
                for ( final Class<?> currentInterface : supportedInterfaces ){
                    System.out.printf( " %s",  currentInterface.getSimpleName() );
                }//for
            }//if
            System.out.printf( "\n" );

            // field(s)/"variable(s)"
            final List<Field> fieldList = new ArrayList<Field>();
            Class<?> currentClass = theClass;
            while ( Object.class != currentClass ){                                 // <=> null != currentClass.getSuperclass() ; skip Object class - no interrest in that
                fieldList.addAll( Arrays.asList( currentClass.getDeclaredFields() ));
                currentClass = currentClass.getSuperclass();
            }//while
            //
            for ( final Class<?> currentInterface : supportedInterfaces ){
                fieldList.addAll( Arrays.asList( currentInterface.getDeclaredFields() ));
            }//for
            // fieldList enthaelt jetzt alle Variablen
            //
            for ( final Field currentField : fieldList ){
                if( !Pattern.matches( ".*\\$.*", currentField.getName() )){         // check for auto generated names (e.g. "$assertionsDisabled")      _???_160122
                    currentField.setAccessible( true );
                    System.out.printf(
                        "~~~~~~~field:  (\"%s\".) %s   is   \"%s\"   [: %s %s]\n",
                        currentField.getDeclaringClass().getSimpleName(),
                        currentField.getName(),
                        currentField.get( objectUnderTest ),
                        modifiersToString( currentField.getModifiers() ),
                        currentField.getType().getSimpleName()
                    );
                }//if
            }//for
            
            // toString()
            System.out.printf( "~.toString():  %s\n",  objectUnderTest.toString() );
        }catch ( IllegalAccessException ex ){
            ex.printStackTrace();
            if (true) throw new IllegalStateException( "GUARD: did NOT expect to end up here" );
        }//try
    }//method()
    
        
    /**
     * prints detailed information about given object
     *
     * @param  requestedClassName  class name 
     *
     * @throws  TestSupportException
     */
    public static void printDetailedInfoAboutClass (
        final String requestedClassName
    ) throws TestSupportException {
        try{
            final List<String> staticStuff = new ArrayList<String>();           // SHF@210805: Schmuddel extension
            
            final Class<?> classUnderTest = Class.forName( requestedClassName );
            
            // class
            final int actualModifiers = classUnderTest.getModifiers();
            System.out.printf( "~~~~~~~class:  %s   is   %s",  classUnderTest.getSimpleName(), modifiersToString( actualModifiers ));
            //
            if( Modifier.isStatic( classUnderTest.getModifiers()) ){            // SHF@210805: Schmuddel extension
                staticStuff.add( classUnderTest.getName() );
            }//if

            
            if( isClass( classUnderTest )){
                final Class<?> superClass = classUnderTest.getSuperclass();
                if( superClass != Object.class ){
                    System.out.printf( " extends %s", superClass.getSimpleName() );
                }//if
            }//if
            
            final Class<?>[] supportedInterfaces = classUnderTest.getInterfaces();
            if( 0 < supportedInterfaces.length ){
                System.out.printf( " implements" );
                for ( Class<?> currentInterface : supportedInterfaces ){
                    System.out.printf( " %s",  currentInterface.getSimpleName() );
                }//for
            }//if
            System.out.printf( "\n" );
            
            // constructor(s)
            final Constructor<?>[] constructors = classUnderTest.getConstructors();
            //
            for( final Constructor<?> constructor : constructors ){
                final String constructorName = constructor.getName();
                final String classUnderTestName = classUnderTest.getSimpleName();
                System.out.printf(
                    "~constructor:  %s()   is   %s (",
                    constructorName.matches( String.format( "a\\d\\.%s", classUnderTestName ) )  ?  classUnderTestName  :  constructor.getName(),
                    modifiersToString( constructor.getModifiers() )
                );
                final Class<?>[] parameterTypes = constructor.getParameterTypes();
                for( final Class<?> actualParameterType : parameterTypes ){
                    System.out.printf( " %s",  actualParameterType.getSimpleName() );
                }//for
                System.out.printf( " )\n" );
                //
                if( Modifier.isStatic( constructor.getModifiers()) ){           // SHF@210805: Schmuddel extension
                    staticStuff.add( constructorName );
                }//if
            }//for
            
            // method(s)
            final Method[] methods = classUnderTest.getMethods();
            for( final Method actualMethod : methods ){
                if ( actualMethod.getDeclaringClass() == classUnderTest ){
                    System.out.printf( "~~~~~~method:  %s()   is   %s ",  actualMethod.getName(), modifiersToString( actualMethod.getModifiers() ) );
                    final Class<?> actualReturnType = actualMethod.getReturnType();
                    System.out.printf( "%s (",  actualReturnType.getSimpleName() );
                    final Class<?>[] parameterTypes = actualMethod.getParameterTypes();
                    for( final Class<?> actualParameterType : parameterTypes ){
                        System.out.printf( " %s",  actualParameterType.getSimpleName() );
                    }//for
                    System.out.printf( " )\n" );
                    //
                    if( Modifier.isStatic( actualMethod.getModifiers()) ){      // SHF@210805: Schmuddel extension
                        staticStuff.add( actualMethod.getName() );
                    }//if
                }//if
            }//for
            
            // field(s)/"variable(s)"
            final Field[] theFields = classUnderTest.getDeclaredFields();
            for ( final Field field : theFields ){
                if (    field.getDeclaringClass() == classUnderTest
                    &&  !Pattern.matches( ".*\\$.*", field.getName() )          // check for auto generated names (e.g. "$assertionsDisabled")      _???_160122
                ){
                    System.out.printf(
                        "~~~~~~~field:  (\"%s\".) %s   is   %s %s\n",
                        classUnderTest.getSimpleName(),
                        field.getName(),
                        modifiersToString( field.getModifiers() ),
                        field.getType().getSimpleName()
                    );
                    //
                    if( Modifier.isStatic( field.getModifiers()) ){             // SHF@210805: Schmuddel extension
                        staticStuff.add( field.getName() );
                    }//if
                }//if
            }//for
            if( isClass( classUnderTest ))  printAndCheck_4_privateField( classUnderTest );
            //
            if( ! staticStuff.isEmpty() ){                                      // SHF@210805: Schmuddel extension
                System.out.printf( "???=>> STATIC stuff to be checked :  %s\n",  staticStuff );
            }//if
            
        }catch( final ClassNotFoundException ex ){
            throw new TestSupportException( String.format( "class \"%s\" can NOT be found", requestedClassName ),  ex );
        }//try
        
    }//method()
    
    
    private static String modifiersToString( final int codedModifiers ){
        StringBuffer sb = new StringBuffer();
        BlankRequiredState blankRequired = new BlankRequiredState();
        if (        Modifier.isStatic(          codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "static" );
        if (        Modifier.isFinal(           codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "final" );
        if (        Modifier.isPublic(          codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "public" );
        if (        Modifier.isProtected(       codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "protected" );
        if (        Modifier.isPrivate(         codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "private" );
        if ( ! (    Modifier.isPrivate(         codedModifiers )
                ||  Modifier.isProtected(       codedModifiers )
                ||  Modifier.isPublic(          codedModifiers )
        ))                                                          modifiersToStringHandleDetails( sb, blankRequired, "\"friendly\"" );
        //
        if (        Modifier.isVolatile(        codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "volatile" );
        if (        Modifier.isTransient(       codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "transient" );
        if (        Modifier.isStrict(          codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "strict" );
        if (        Modifier.isNative(          codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "native" );
        if (        Modifier.isAbstract(        codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "abstract" );
        if (        Modifier.isSynchronized(    codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "synchronized" );
        if (        Modifier.isInterface(       codedModifiers ))   modifiersToStringHandleDetails( sb, blankRequired, "interface" );
        return sb.toString();
    }//method()
    //
    private static void modifiersToStringHandleDetails( final StringBuffer sb,  final BlankRequiredState blankRequired,  final String modifier ){
        if( blankRequired.getRequiredState() ){ sb.append( " " ); }
        sb.append( modifier );
        blankRequired.setRequired();
    }//method()
    //
    private static class BlankRequiredState {
        public boolean getRequiredState(){ return blankRequired; }
        public void setRequired(){ blankRequired = true; }
        
        public BlankRequiredState(){ blankRequired = false; }
        
        private boolean blankRequired;
    }//class
    
    
    
    
    
    
    
    
    
    
    //##########################################################################
    //###VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //###
    //###   some print&check support methods for manual code inspection
    //###   ===========================================================
    //###
    
    
    /**
     * prints and checks if class(-object) is abstract
     *
     * @param classUnderTest  class(-object)
     */
    public static void printAndCheck_4_abstract (
        final Class<?>  classUnderTest
    ){
        final boolean test = Modifier.isAbstract( classUnderTest.getModifiers() );
        if ( test ){
            System.out.printf( "OK:    %s is abstract\n",  classUnderTest.getSimpleName() );
        }else{
            Herald.proclaimMessage( SYS_ERR,  String.format( "ERROR: %s is NOT abstract",  classUnderTest.getSimpleName() ));
        }//if
    }//method()
    
    
    /**
     * prints and checks if given class(-object) is implementing given interface
     *
     * @param classUnderTest  class(-object)
     * @param wintf           wanted interface
     */
    public static void printAndCheck_4_interface (
        final Class<?>  classUnderTest,
        final Class<?>  wintf
    ){
        final Class<?>[] theInterfaces = classUnderTest.getInterfaces();
        boolean test = false;
        loop:
        for ( Class<?> cintf : theInterfaces ){
            if ( cintf == wintf ){
                test = true;
                break loop;
            }//if
        }//loop:for
        if ( test ){
            System.out.printf( "OK:    %s implements %s\n",  classUnderTest.getSimpleName(), wintf.getSimpleName() );
        }else{
            Herald.proclaimMessage( SYS_ERR,  String.format(
                "ERROR: %s implements NOT %s",
                classUnderTest.getSimpleName(),
                wintf.getSimpleName()
            ));
        }//if
    }//method()
    
    
    /**
     * prints and checks if given class(-object) is extending given super class
     *
     * @param classUnderTest  class(-object)
     * @param superclazz      super class(-object)
     */
    public static void printAndCheck_4_superClass (
        final Class<?>  classUnderTest,
        final Class<?>  superclazz
    ){
        final boolean test = ( superclazz == classUnderTest.getSuperclass() );
        if ( test ){
            System.out.printf( "OK:    %s extends %s\n",  classUnderTest.getSimpleName(), superclazz.getSimpleName() );
        }else{
            Herald.proclaimMessage( SYS_ERR,  String.format(
                "ERROR: %s extends NOT %s",
                classUnderTest.getSimpleName(),
                superclazz.getSimpleName()
            ));
        }//if
    }//method()
    
    
    
    /**
     * Checks if given class(-object) is implementing directly given method
     *
     * @param classUnderTest  class(-object)
     * @param methodName      method name
     *
     * @return  true if given class(-object) is implementing directly given method, otherwise false
     */
    public static boolean check_4_methName (
        final Class<?>  classUnderTest,
        final String  methodName
    ){
        final Method[] theMethods = classUnderTest.getMethods();
        boolean test = false;
        loop:
        for ( Method meth : theMethods ){
            if ( methodName.equals( meth.getName() )  &&  classUnderTest == meth.getDeclaringClass() ){
                test = true;
                break loop;
            }//if
        }//loop:for
        return test;
    }//method()
    //
    /**
     * prints and checks if given class(-object) is implementing directly given method
     *
     * @param classUnderTest  class(-object)
     * @param methName        method name
     * @param errLevel        error level (e.g.: error)
     */
    public static void printAndCheck_4_methName (
        final Class<?> classUnderTest,
        final String methName,
        final String errLevel
    ){
        final int reservedSpace = 6;
        if ( check_4_methName( classUnderTest, methName ) ){
            System.out.printf(//vvvvvV vvV            vvV
                String.format( "%%-%ds %%s implements %%s()\n",  reservedSpace ),
                "OK:",
                classUnderTest.getSimpleName(),
                methName
            );
        }else{
            if ( "error".equals( errLevel.toLowerCase() ) ){
                Herald.proclaimMessage(
                    SYS_ERR,
                    String.format(//    vvvvvV vvV                    vvV
                        String.format( "%%-%ds %%s does NOT implement %%s()\n",  reservedSpace ),
                        (errLevel+":"),
                        classUnderTest.getSimpleName(),
                        methName
                    )
                );
            }else{
                System.out.printf(//vvvvvV vvV                    vvV
                    String.format( "%%-%ds %%s does NOT implement %%s()\n",  reservedSpace ),
                    (errLevel+":"),
                    classUnderTest.getSimpleName(),
                    methName
                );
            }//if
        }//if
    }//method()
    
    
    
    /**
     * prints and checks if given field of given class(-object) is private
     *
     * @param classUnderTest  class(-object)
     * @param fieldName       name of field to be checked
     */
    public static void printAndCheck_4_privateField (
        final Class<?>  classUnderTest,
        final String  fieldName
    ){
        final Field[] theFields = classUnderTest.getDeclaredFields();
        boolean test = false;
        loop:
        for ( Field field : theFields ){
            if ( fieldName.equals( field.getName() )  &&  Modifier.isPrivate( field.getModifiers() ) ){
                test = true;
                break loop;
            }//if
        }//loop:for
        if ( test ){
            System.out.printf( "OK:    %s.%s is private\n",  classUnderTest.getSimpleName(), fieldName );
        }else{
            System.out.printf( "ERROR: %s.%s is NOT private\n",  classUnderTest.getSimpleName(), fieldName );
        }//if
    }//mwthod()
    //
    /**
     * prints and checks given class(-object) directly contains any private field
     *
     * @param classUnderTest  class(-object)
     */
    public static void printAndCheck_4_privateField(
        final Class<?>  classUnderTest
    ){
        final Field[] theFields = classUnderTest.getDeclaredFields();
        boolean ok = true;
        for ( Field field : theFields ){
            if (    field.getDeclaringClass() == classUnderTest
                &&  !Modifier.isPrivate( field.getModifiers() )
                &&  !Pattern.matches( ".*\\$.*", field.getName() ) 
            ){
                ok = false;
                System.out.printf( "ERROR: %s -> \"%s\":%s is NOT private\n",  classUnderTest.getSimpleName(), field.getName(), field.getDeclaringClass() );
            }//if
        }//for
        if ( ok ){
            System.out.printf( "OK: All fields (found) of %s are private\n",  classUnderTest.getSimpleName() );
        }//if
    }//method()
    
    
    /**
     * Prints all fields of given class(-object)
     *
     * @param classUnderTest  the class, whose fields have to be printed
     */
    public static void printAllFieldsOfClass (
        final Class<?>  classUnderTest
    ){
        final Field[] theFields = classUnderTest.getDeclaredFields();
        for ( Field field : theFields ){
            if ( field.getDeclaringClass() == classUnderTest ){
                System.out.printf( "(\"%s\".)%s is ",  classUnderTest.getSimpleName(), field.getName(), field.getModifiers() );
                if ( Modifier.isStatic(        field.getModifiers() ))  System.out.printf( "static " );
                if ( Modifier.isFinal(         field.getModifiers() ))  System.out.printf( "final " );
                if ( Modifier.isPublic(        field.getModifiers() ))  System.out.printf( "public " );
                if ( Modifier.isProtected(     field.getModifiers() ))  System.out.printf( "protected " );
                if ( Modifier.isPrivate(       field.getModifiers() ))  System.out.printf( "private " );
                if ( ! ( Modifier.isPrivate(   field.getModifiers() ) || Modifier.isProtected( field.getModifiers() ) || Modifier.isPublic( field.getModifiers() )))  System.out.printf( "friendly " );
                //
                if ( Modifier.isVolatile(      field.getModifiers() ))  System.out.printf( "volatile " );
                if ( Modifier.isTransient(     field.getModifiers() ))  System.out.printf( "transient " );
                if ( Modifier.isStrict(        field.getModifiers() ))  System.out.printf( "strict " );
                if ( Modifier.isNative(        field.getModifiers() ))  System.out.printf( "native " );
                if ( Modifier.isAbstract(      field.getModifiers() ))  System.out.printf( "abstract " );
                if ( Modifier.isSynchronized(  field.getModifiers() ))  System.out.printf( "synchronized " );
                if ( Modifier.isInterface(     field.getModifiers() ))  System.out.printf( "interface " );
                System.out.printf( "\n" );
            }//if
        }//loop_for
    }//method()
    
    
    /**
     * Gets all modifiers of given field as String
     *
     * @param field  the field
     *
     * @return  modifiers of given field (as String)
     */
    public static String getAllModifiersOfField(
        final Field field
    ){
        StringBuffer sb = new StringBuffer();
        if ( Modifier.isStatic(        field.getModifiers() ))  sb.append( "static " );
        if ( Modifier.isFinal(         field.getModifiers() ))  sb.append( "final " );
        if ( Modifier.isPublic(        field.getModifiers() ))  sb.append( "public " );
        if ( Modifier.isProtected(     field.getModifiers() ))  sb.append( "protected " );
        if ( Modifier.isPrivate(       field.getModifiers() ))  sb.append( "private " );
        if ( ! ( Modifier.isPrivate(   field.getModifiers() ) || Modifier.isProtected( field.getModifiers() ) || Modifier.isPublic( field.getModifiers() )))  sb.append( "\"friendly\" " );
        //
        if ( Modifier.isVolatile(      field.getModifiers() ))  sb.append( "volatile " );
        if ( Modifier.isTransient(     field.getModifiers() ))  sb.append( "transient " );
        if ( Modifier.isStrict(        field.getModifiers() ))  sb.append( "strict " );
        if ( Modifier.isNative(        field.getModifiers() ))  sb.append( "native " );
        if ( Modifier.isAbstract(      field.getModifiers() ))  sb.append( "abstract " );
        if ( Modifier.isSynchronized(  field.getModifiers() ))  sb.append( "synchronized " );
        if ( Modifier.isInterface(     field.getModifiers() ))  sb.append( "interface " );
        return sb.toString();
    }//method()
    
    
    /**
     * Prints all numeric fields of given object, but only those belonging to the classes defined by checklist.
     *
     * @param obj        the object, whose numeric fields have to be printed
     * @param checkList  classes containing the fields to be printed 
     */
    public static void printALLnumericFieldValues (
        final Object obj,
        Class<?>... checkList
    ){
        final List<Field> fieldList = new ArrayList<Field>();
        Class<?> currentClazz = obj.getClass();
        while ( Object.class != currentClazz ){                                 // <=> null != currentClazz.getSuperclass() ; skip Object class - no interrest in that
            fieldList.addAll( Arrays.asList( currentClazz.getDeclaredFields() ));
            currentClazz = currentClazz.getSuperclass();
        }//while
        // fieldList enthaelt jetzt alle Variablen
        //
        try{
            for ( Class<?> current : checkList ){
                final Iterator<Field> iter = fieldList.iterator();
                while ( iter.hasNext() ){
                    final Field field = iter.next();
                    field.setAccessible( true );
                    if ( field.getDeclaringClass() == current  ){
                        if (    byte.class == field.getType()  ||  short.class == field.getType()  ||  int.class     == field.getType()  ||  long.class == field.getType()  ||  char.class      == field.getType()
                            ||  Byte.class == field.getType()  ||  Short.class == field.getType()  ||  Integer.class == field.getType()  ||  Long.class == field.getType()  ||  Character.class == field.getType()
                        ){
                            long value = 0;
                            if      ( field.getType() == byte.class   ||  field.getType() == Byte.class )       value = field.getByte( obj );
                            else if ( field.getType() == short.class  ||  field.getType() == Short.class )      value = field.getShort( obj );
                            else if ( field.getType() == int.class    ||  field.getType() == Integer.class )    value = field.getInt( obj );
                            else if ( field.getType() == long.class   ||  field.getType() == Long.class )       value = field.getLong( obj );
                            else if ( field.getType() == char.class   ||  field.getType() == Character.class )  value = field.getChar( obj );
                            System.out.printf(
                                "(\"%s\".) %s  ->  %d     %s     %s\n",
                                current.getSimpleName(),
                                field.getName(),
                                value,
                                field.getType(),
                                getAllModifiersOfField( field )
                            );
                            iter.remove();
                        }//if
                    }//if
                }//while
            }//for
            if ( ! fieldList.isEmpty() ){
                System.out.printf( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\n");
                for ( Field field : fieldList ){
                    field.setAccessible( true );
                    System.out.printf(
                        "(\"%s\".) %s  ~>  %s     %s\n",
                        field.getDeclaringClass().getSimpleName(),
                        field.getName(),
                        field.getType().getSimpleName(),
                        getAllModifiersOfField( field )
                    );
                }//for    
            }//if
        }catch ( IllegalArgumentException | IllegalAccessException ex ){
            ex.printStackTrace();
            if (true) throw new IllegalStateException( "GUARD: did NOT expect to end up here" );
        }//try
    }//method()
    
    
    
    /**
     * Prints all fields of given object
     *
     * @param obj  the object, whose fields have to be printed
     */
    public static void printAllFieldsOfObject (
        final Object obj
    ){
        final List<Field> fieldList = new ArrayList<Field>();
        Class<?> currentClazz = obj.getClass();
        while ( Object.class != currentClazz ){                                 // <=> null != currentClazz.getSuperclass() ; skip Object class - no interrest in that
            fieldList.addAll( Arrays.asList( currentClazz.getDeclaredFields() ));
            currentClazz = currentClazz.getSuperclass();
        }//while
        // fieldList enthaelt jetzt alle Variablen
        //
        try{
            for ( Field field : fieldList ){
                field.setAccessible( true );
                System.out.printf(
                    "(\"%s\".) %s   is   %s %s\n",
                    field.getDeclaringClass().getSimpleName(),
                    field.getName(),
                    field.getType().getSimpleName(),
                    getAllModifiersOfField( field )
                );
            }//for    
        }catch ( IllegalArgumentException ex ){
            ex.printStackTrace();
            if (true) throw new IllegalStateException( "GUARD: did NOT expect to end up here" );
        }//try
    }//method()
    
    
    
    
    
    
    
    
    
    
    //##########################################################################
    //###VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //###
    //###   default implementations for "@BeforeClass" + "@AfterClass"
    //###   ==========================================================
    //###
    
    
    /**
     * Runs test setup before any unit test starts
     *
     * @param dbManager  dbManger
     * @param exercise   exercise
     */
    public static void runTestSetupBeforeAnyUnitTestStarts (
        final TestResultDataBaseManager  dbManager, 
        final TE  exercise,
        final String  rootPackageName
    ){
        if( null==dbManager ){
            throw new IllegalArgumentException( "data base manager must NOT be null - this might indicate an internal coding error => call schaefers" );
        }//if
        if( null==exercise ){
            throw new IllegalArgumentException( "test exercise must NOT be null - this might indicate an internal coding error => call schaefers" );
        }//if
        //\=> valid paramter
        
        
        System.out.printf( "Informationen zum Environment:\n" );
        System.out.printf( "    O.-P.:      %s\n",          new Object().getClass().getPackage() );
        System.out.printf( "    Java (v1):  %s bzw. %s\n",  System.getProperty( "java.specification.version" ), System.getProperty( "java.version" ) );
        System.out.printf( "    Java (v2):          %s\n",  EnvironmentAnalyzer.getJavaVersion() );
        System.out.printf( "    JUnit5/Jupiter:     %s\n",  EnvironmentAnalyzer.getJUnitJupiterVersion() );
        System.out.printf( "    JUnit5/Platform:    %s\n",  EnvironmentAnalyzer.getJUnitPlatformVersion() );
        System.out.printf( "    #Cores:             %d\n",  EnvironmentAnalyzer.getAvailableCores() );
        System.out.printf( "    ------------\n" );
        System.out.printf( "    WPI computer :                                              %s\n",   CentralVersionData.centralWPIComputerVersionID );
        System.out.printf( "    Engine   (test support routine collection) :                %s\n",   CentralVersionData.centralTestSupportVersionID );
        System.out.printf( "    Test     (test defined by version ID) :                     %s\n",   CentralVersionData.centralLabExamVersionID );
//TODO  System.out.printf( "    Exam     (test defined by path) :                           %s%s\n",  TestFrameC1x01.class.getProtectionDomain().getCodeSource().getLocation().getPath(), packagePath );
        System.out.printf( "    Exercise (test defined by internal test definition/enum) :  %s\n",    exercise );
        System.out.printf( "\n" );
        System.out.printf( "################################################################################\n" );
        System.out.printf( "\n\n" );
        try{
            // print name of examinee
            final Object examineeInfo = TS.generateRequestedObject( rootPackageName+".a1.ExamineeInfo" );
            final String sName = (String)( TS.callFunction( examineeInfo, "getExamineeSurName",   null, null ) );
            final String fName = (String)( TS.callFunction( examineeInfo, "getExamineeFirstName", null, null ) );
            System.out.printf( "%s_%s : %s\n",  sName, fName, exercise );
            System.out.printf( "\n" );
            
            // check examinee status resp. a1-I
            int a1iPoints = 0;
            final TestResultTable table = dbManager.loadSynchronizedExerciseRelatedResults();
            if( null!=table ){
                for( final TestTopic tt : table.keySet() ){
                    if(( TE.A1 == tt.getExercise() )  &&  ( TL.I == tt.getLevel() )){
                        final Set<TestResult> testResultSet = table.get( tt );
                        for( final TestResult tr : testResultSet ){
                            a1iPoints +=  tr.getWeight();
                        }//for
                    }//if
                }//for
            }//if
            if( a1iPoints < Configuration.valuationTable.get( new ValuationUnit( TL.I, TE.A1 ) )){
                throw new TestSupportException(
                    String.format(
                        "FINISH A1 FIRST !!!    (%d<%d)",
                        a1iPoints,
                        Configuration.valuationTable.get( new ValuationUnit( TL.I, TE.A1 ) )
                    )
                );
            }//if
            
        }catch( final TestSupportException ex ){
            System.out.flush();
            System.err.printf( "\n" );
            ex.printStackTrace();
            System.err.printf( "\n\n" );
            System.err.printf( "Loesen Sie erst Aufgabe a1 !!!\n" );
            System.err.printf( "Ohne eine korrekt geloeste Aufgabe a1 macht die Bearbeitung aller anderen Aufgaben KEINEN Sinn!\n" );
            System.err.flush();
            System.out.printf( "\n\n" );
            System.out.printf( "###\n" );
            System.out.printf( "### Loesen Sie erst Aufgabe a1 !!!\n" );
            System.out.printf( "### Ohne eine korrekt geloeste Aufgabe a1 macht die Bearbeitung aller anderen Aufgaben KEINEN Sinn!\n" );
            System.out.printf( "###\n" );
            JUW.jufail( ex.getMessage() );
        }finally{
            System.out.flush();
        }//try
    }//method()
    
    
    /**
     * Runs test tear down after all unit tests have finished
     *
     * @param dbManager dbManger
     */
    public static void runTestTearDownAfterAllUnitTestsHaveFinished (
        final TestResultDataBaseManager  dbManager,
        final String  rootPackageName
    ){
        if( null==dbManager ){
            throw new IllegalArgumentException( "data base manager must NOT be null - this might indicate an internal coding error => call schaefers" );
        }//if
        //\=> valid paramter
        
        // store results into database
        dbManager.updateSynchronizedExerciseRelatedResults();
        
        
        // print configured information on screen
        System.err.flush();                                                     // for safty's sake - there might have been error messages
        
        final TestResultTable  exerciseTestResults  = dbManager.currentTestResults;
        final TestResultAnalyzer testResultAnalyzer = new TestResultAnalyzer( exerciseTestResults );
        boolean dbgLocalOutputEnable;
        boolean newLineRequested = false;
        
        dbgLocalOutputEnable = ( 0 != ( dbgConfigurationVector & 0b0100 ));
        if( dbgLocalOutputEnable ){
            if( newLineRequested )  System.out.printf( "\n" );
            exerciseTestResults.prettyPrint();
            newLineRequested = true;
        }//if
        
        dbgLocalOutputEnable = ( 0 != ( dbgConfigurationVector & 0b0010 ));
        if( dbgLocalOutputEnable ){
            if( newLineRequested )  System.out.printf( "\n" );
            testResultAnalyzer.printPerformanceDetailed();
            newLineRequested = true;
        }//if
        
        dbgLocalOutputEnable = ( 0 != ( dbgConfigurationVector & 0b0001 ));
        if( dbgLocalOutputEnable ){
            if( newLineRequested )  System.out.printf( "\n" );
            testResultAnalyzer.printPerformance();
            newLineRequested = true;
        }//if
        if( newLineRequested )  System.out.printf( "\n" );
        System.out.printf( "################################################################################\n" );
        try{
            // print name of examinee
            final Object examineeInfo = TS.generateRequestedObject( rootPackageName + ".a1.ExamineeInfo" );
            final String sName = (String)( TS.callFunction( examineeInfo, "getExamineeSurName",   null, null ) );
            final String fName = (String)( TS.callFunction( examineeInfo, "getExamineeFirstName", null, null ) );
            System.out.printf( "### %s_%s ### ",  sName, fName );
        }catch( final TestSupportException ex ){
            // "HERE" is NOT the place to handle ExamineeInfo related errors - this has to be done before
            // Hence, nothing is done "HERE"
            Herald.proclaimMessage( SYS_ERR, String.format(
                "SEVERE PROBLEM - most probably an ExamineeInfo related error caused by examinee has occurred\n"
            ));
        }//try
        System.out.printf( "The End\n\n" );
        System.out.flush();
    }//method()
    
}//class
